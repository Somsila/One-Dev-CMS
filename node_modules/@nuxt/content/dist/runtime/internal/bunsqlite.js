import * as zlib from "node:zlib";
import { isAbsolute } from "pathe";
if (!globalThis.CompressionStream) {
  const make = (ctx, handle) => Object.assign(ctx, {
    writable: new WritableStream({
      write: (chunk) => handle.write(chunk),
      close: () => handle.end()
    }),
    readable: new ReadableStream({
      type: "bytes",
      start(ctrl) {
        handle.on("data", (chunk) => ctrl.enqueue(chunk));
        handle.once("end", () => ctrl.close());
      }
    })
  });
  globalThis.CompressionStream = class CompressionStream {
    constructor(format) {
      make(this, format === "deflate" ? zlib.createDeflate() : format === "gzip" ? zlib.createGzip() : zlib.createDeflateRaw());
    }
  };
  globalThis.DecompressionStream = class DecompressionStream {
    constructor(format) {
      make(this, format === "deflate" ? zlib.createInflate() : format === "gzip" ? zlib.createGunzip() : zlib.createInflateRaw());
    }
  };
}
function getBunDatabaseSync() {
  return require("bun:sqlite").Database;
}
let db;
export const getBunSqliteDatabaseAdapter = (opts) => {
  const Database = getBunDatabaseSync();
  if (!db) {
    const filename = !opts || isAbsolute(opts?.filename || "") || opts?.filename === ":memory:" ? opts?.filename : new URL(opts.filename, globalThis._importMeta_.url).pathname;
    db = new Database(process.platform === "win32" && filename.startsWith("/") ? filename.slice(1) : filename, { create: true });
  }
  return {
    async all(sql, params) {
      return params ? db.prepare(sql).all(...params) : db.prepare(sql).all();
    },
    async first(sql, params) {
      return params ? db.prepare(sql).get(...params) : db.prepare(sql).get();
    },
    async exec(sql) {
      return db.prepare(sql).run();
    }
  };
};
