import { decompressSQLDump } from "./dump.js";
import { fetchDatabase } from "./api.js";
import { tables, checksums } from "#content/manifest";
import adapter from "#content/adapter";
export default function loadDatabaseAdapter(config) {
  const { database, localDatabase } = config;
  let _adapter;
  async function loadAdapter() {
    if (!_adapter) {
      if (import.meta.dev || ["nitro-prerender", "nitro-dev"].includes(import.meta.preset)) {
        _adapter = await loadSqliteAdapter(localDatabase);
      } else {
        _adapter = adapter(database);
      }
    }
    return _adapter;
  }
  return {
    all: async (sql, params) => {
      const db = await loadAdapter();
      return await db.all(sql, params);
    },
    first: async (sql, params) => {
      const db = await loadAdapter();
      return await db.first(sql, params);
    },
    exec: async (sql) => {
      const db = await loadAdapter();
      return db.exec(sql);
    }
  };
}
const checkDatabaseIntegrity = {};
const integrityCheckPromise = {};
export async function checkAndImportDatabaseIntegrity(event, collection, config) {
  if (checkDatabaseIntegrity[String(collection)] !== false) {
    checkDatabaseIntegrity[String(collection)] = false;
    integrityCheckPromise[String(collection)] = integrityCheckPromise[String(collection)] || _checkAndImportDatabaseIntegrity(event, collection, checksums[String(collection)], config).then((isValid) => {
      checkDatabaseIntegrity[String(collection)] = !isValid;
    }).catch((error) => {
      console.error("Database integrity check failed", error);
      checkDatabaseIntegrity[String(collection)] = true;
      integrityCheckPromise[String(collection)] = null;
    });
  }
  if (integrityCheckPromise[String(collection)]) {
    await integrityCheckPromise[String(collection)];
  }
}
async function _checkAndImportDatabaseIntegrity(event, collection, integrityVersion, config) {
  const db = await loadDatabaseAdapter(config);
  const before = await db.first(`select * from ${tables.info} where id = 'checksum_${collection}'`).catch(() => ({ version: "" }));
  if (before?.version) {
    if (before?.version === integrityVersion) {
      return true;
    }
    await db.exec(`DELETE FROM ${tables.info} WHERE id = 'checksum_${collection}'`);
  }
  const dump = await loadDatabaseDump(event, collection).then(decompressSQLDump);
  await dump.reduce(async (prev, sql) => {
    await prev;
    await db.exec(sql).catch((err) => {
      const message = err.message || "Unknown error";
      console.error(`Failed to execute SQL ${sql}: ${message}`);
    });
  }, Promise.resolve());
  const after = await db.first(`SELECT * FROM ${tables.info} WHERE id = 'checksum_${collection}'`).catch(() => ({ version: "" }));
  return after?.version === integrityVersion;
}
async function loadDatabaseDump(event, collection) {
  return await fetchDatabase(event, String(collection)).catch((e) => {
    console.error("Failed to fetch compressed dump", e);
    return "";
  });
}
function loadSqliteAdapter(config) {
  return import("../adapters/sqlite.js").then((m) => m.default(config));
}
